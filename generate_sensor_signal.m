function [return_signal] = generate_sensor_signal(resolution, downsample_ratio, offset, shift_vector, depth_map, T_0)
%Generate AMCW LiDAR return signal profile based on given depth_map
%   Assume the light source is non-collimate:
%   The intensity of return signal follows inverse square rule

    % signal
    return_signal = SensorSignal(resolution*downsample_ratio, 1);
    return_signal.shift_vector = round(shift_vector*downsample_ratio); % ensure full pixel translate
    return_signal.T_0 = T_0;
    nearfield_thres = 0.001 * return_signal.T_0 * return_signal.lightspeed;
    farfield_thres = 2 * return_signal.T_0 * return_signal.lightspeed;

    % sub-pixel shift
    depth_map = imtranslate_general(depth_map, -round((offset+shift_vector)*downsample_ratio), 'FillValues',Inf);
    crop_rect = centerCropWindow2d(size(depth_map), resolution*downsample_ratio);
    depth_map = imcrop(depth_map, crop_rect);

    % remove distance too close (i.e. zero), not needed for collimate version
    depth_map = (depth_map >= nearfield_thres) .* depth_map...
              + (depth_map < nearfield_thres) .* farfield_thres;

    % signal return time
    F1_return_time = 2*depth_map ./ return_signal.lightspeed + T_0/2;
    F2_return_time = 2*depth_map ./ return_signal.lightspeed;
    F3_return_time = 2*depth_map ./ return_signal.lightspeed + T_0/2;
    F4_return_time = 2*depth_map ./ return_signal.lightspeed;

    % signal values
    % F1
    return_signal.F1_VTX1...
        = (F1_return_time < T_0) .* (T_0 - F1_return_time)...
        + ((T_0 <= F1_return_time) & (F1_return_time < 2*T_0)) .* (F1_return_time - T_0)...
        + ((2*T_0 <= F1_return_time) & (F1_return_time < 3*T_0)) .* (3*T_0 - F1_return_time)...
        + (3*T_0 <= F1_return_time) .* zeros(size(F1_return_time));
    return_signal.F1_VTX1(isnan(return_signal.F1_VTX1)) = 0;
    return_signal.F1_VTX1 = return_signal.F1_VTX1 .* depth_map.^-2;
    return_signal.F1_VTX2...
        = (F1_return_time < T_0) .* (F1_return_time + T_0 - T_0)...
        + ((T_0 <= F1_return_time) & (F1_return_time < 2*T_0)) .* (2*T_0 - F1_return_time)...
        + ((2*T_0 <= F1_return_time) & (F1_return_time < 3*T_0)) .* (F1_return_time - 2*T_0)...
        + ((3*T_0 <= F1_return_time) & (F1_return_time < 4*T_0)) .* (4*T_0 - F1_return_time)...
        + (4*T_0 <= F1_return_time) .* zeros(size(F1_return_time));
    return_signal.F1_VTX2(isnan(return_signal.F1_VTX2)) = 0;
    return_signal.F1_VTX2 = return_signal.F1_VTX2 .* depth_map.^-2;
    % F2
    return_signal.F2_VTX1...
        = (F2_return_time < T_0) .* (T_0 - F2_return_time)...
        + ((T_0 <= F2_return_time) & (F2_return_time < 2*T_0)) .* (F2_return_time - T_0)...
        + ((2*T_0 <= F2_return_time) & (F2_return_time < 3*T_0)) .* (3*T_0 - F2_return_time)...
        + (3*T_0 <= F2_return_time) .* zeros(size(F2_return_time));
    return_signal.F2_VTX1(isnan(return_signal.F2_VTX1)) = 0;
    return_signal.F2_VTX1 = return_signal.F2_VTX1 .* depth_map.^-2;
    return_signal.F2_VTX2...
        = (F2_return_time < T_0) .* (F2_return_time + T_0 - T_0)...
        + ((T_0 <= F2_return_time) & (F2_return_time < 2*T_0)) .* (2*T_0 - F2_return_time)...
        + ((2*T_0 <= F2_return_time) & (F2_return_time < 3*T_0)) .* (F2_return_time - 2*T_0)...
        + ((3*T_0 <= F2_return_time) & (F2_return_time < 4*T_0)) .* (4*T_0 - F2_return_time)...
        + (4*T_0 <= F2_return_time) .* zeros(size(F2_return_time));
    return_signal.F2_VTX2(isnan(return_signal.F2_VTX2)) = 0;
    return_signal.F2_VTX2 = return_signal.F2_VTX2 .* depth_map.^-2;
    % F3
    return_signal.F3_VTX1...
        = (F3_return_time < T_0) .* (F3_return_time + T_0 - T_0)...
        + ((T_0 <= F3_return_time) & (F3_return_time < 2*T_0)) .* (2*T_0 - F3_return_time)...
        + ((2*T_0 <= F3_return_time) & (F3_return_time < 3*T_0)) .* (F3_return_time - 2*T_0)...
        + ((3*T_0 <= F3_return_time) & (F3_return_time < 4*T_0)) .* (4*T_0 - F3_return_time)...
        + (4*T_0 <= F3_return_time) .* zeros(size(F3_return_time));
    return_signal.F3_VTX1(isnan(return_signal.F3_VTX1)) = 0;
    return_signal.F3_VTX1 = return_signal.F3_VTX1 .* depth_map.^-2;
    return_signal.F3_VTX2...
        = (F3_return_time < T_0) .* (T_0 - F3_return_time)...
        + ((T_0 <= F3_return_time) & (F3_return_time < 2*T_0)) .* (F3_return_time - T_0)...
        + ((2*T_0 <= F3_return_time) & (F3_return_time < 3*T_0)) .* (3*T_0 - F3_return_time)...
        + (3*T_0 <= F3_return_time) .* zeros(size(F3_return_time));
    return_signal.F3_VTX2(isnan(return_signal.F3_VTX2)) = 0;
    return_signal.F3_VTX2 = return_signal.F3_VTX2 .* depth_map.^-2;
    % F4
    return_signal.F4_VTX1...
        = (F4_return_time < T_0) .* (F4_return_time + T_0 - T_0)...
        + ((T_0 <= F4_return_time) & (F4_return_time < 2*T_0)) .* (2*T_0 - F4_return_time)...
        + ((2*T_0 <= F4_return_time) & (F4_return_time < 3*T_0)) .* (F4_return_time - 2*T_0)...
        + ((3*T_0 <= F4_return_time) & (F4_return_time < 4*T_0)) .* (4*T_0 - F4_return_time)...
        + (4*T_0 <= F4_return_time) .* zeros(size(F4_return_time));
    return_signal.F4_VTX1(isnan(return_signal.F4_VTX1)) = 0;
    return_signal.F4_VTX1 = return_signal.F4_VTX1 .* depth_map.^-2;
    return_signal.F4_VTX2...
        = (F4_return_time < T_0) .* (T_0 - F4_return_time)...
        + ((T_0 <= F4_return_time) & (F4_return_time < 2*T_0)) .* (F4_return_time - T_0)...
        + ((2*T_0 <= F4_return_time) & (F4_return_time < 3*T_0)) .* (3*T_0 - F4_return_time)...
        + (3*T_0 <= F4_return_time) .* zeros(size(F4_return_time));
    return_signal.F4_VTX2(isnan(return_signal.F4_VTX2)) = 0;
    return_signal.F4_VTX2 = return_signal.F4_VTX2 .* depth_map.^-2;

%     % diffencial value
%     return_signal.delta_F1 = return_signal.F1_VTX2 - return_signal.F1_VTX1 + return_signal.F3_VTX1 - return_signal.F3_VTX2;
%     return_signal.delta_F2 = return_signal.F2_VTX2 - return_signal.F2_VTX1 + return_signal.F4_VTX1 - return_signal.F4_VTX2;
%     % intensity value
%     return_signal.intensity = return_signal.F1_VTX1 + return_signal.F1_VTX1 + return_signal.F2_VTX1 + return_signal.F2_VTX2...
%                             + return_signal.F3_VTX1 + return_signal.F3_VTX2 + return_signal.F4_VTX1 + return_signal.F4_VTX2;

    return_signal = Scale(return_signal, 1/downsample_ratio);

end

